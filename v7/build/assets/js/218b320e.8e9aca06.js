"use strict";(self.webpackChunkjs_dos=self.webpackChunkjs_dos||[]).push([[146],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var i=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=i.createContext({}),d=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=d(e.components);return i.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=d(n),m=o,h=c["".concat(l,".").concat(m)]||c[m]||p[m]||r;return n?i.createElement(h,a(a({ref:t},u),{},{components:n})):i.createElement(h,a({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,a=new Array(r);a[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var d=2;d<r;d++)a[d]=n[d];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"},571:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return a},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return d},default:function(){return p}});var i=n(4034),o=n(9973),r=(n(7294),n(3905)),a={id:"contributing-emulators",title:"Contributing"},s=void 0,l={unversionedId:"contributing-emulators",id:"contributing-emulators",isDocsHomePage:!1,title:"Contributing",description:"To contribute to the emulators package do the following:",source:"@site/docs/contributing-emulators.md",sourceDirName:".",slug:"/contributing-emulators",permalink:"/v7/build/docs/contributing-emulators",editUrl:"https://github.com/caiiiycuk/js-dos/edit/gh-pages/v7/docs/contributing-emulators.md",version:"current",frontMatter:{id:"contributing-emulators",title:"Contributing"},sidebar:"someSidebar",previous:{title:"Esitmating emulators performance",permalink:"/v7/build/docs/estimating-performance"},next:{title:"Overview",permalink:"/v7/build/docs/doszone"}},d=[{value:"Protocol",id:"protocol",children:[]},{value:"Server",id:"server",children:[{value:"server_run()",id:"server_run",children:[]},{value:"server_add_key(keycode, pressed, timeMs)",id:"server_add_keykeycode-pressed-timems",children:[]},{value:"server_exit()",id:"server_exit",children:[]}]},{value:"Client",id:"client",children:[{value:"client_frame_set_size(width, height)",id:"client_frame_set_sizewidth-height",children:[]},{value:"client_frame_update_lines(lines, count, rgba)",id:"client_frame_update_lineslines-count-rgba",children:[]},{value:"client_sound_init(freq);",id:"client_sound_initfreq",children:[]},{value:"client_sound_push(samples, num_samples)",id:"client_sound_pushsamples-num_samples",children:[]},{value:"client_stdout(data, amount)",id:"client_stdoutdata-amount",children:[]},{value:"Communicate to server",id:"communicate-to-server",children:[]}]},{value:"Testing",id:"testing",children:[]},{value:"Running native js-dos v7",id:"running-native-js-dos-v7",children:[]},{value:"Using Docker",id:"using-docker",children:[{value:"Build image",id:"build-image",children:[]},{value:"Test image",id:"test-image",children:[]},{value:"Development",id:"development",children:[]}]},{value:"Contributing on github",id:"contributing-on-github",children:[]}],u={toc:d};function p(e){var t=e.components,n=(0,o.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"To contribute to the ",(0,r.kt)("inlineCode",{parentName:"p"},"emulators")," package do the following:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Checkout ",(0,r.kt)("inlineCode",{parentName:"p"},"emulators")," repository"),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"git clone https://github.com/js-dos/emulators"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Install ",(0,r.kt)("a",{parentName:"p",href:"https://emscripten.org/docs/tools_reference/emsdk.html"},"emscripten sdk"),", and confgure environment to use it.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Install ",(0,r.kt)("a",{parentName:"p",href:"https://cmake.org/"},"cmake")," and ",(0,r.kt)("a",{parentName:"p",href:"https://gulpjs.com/"},"gulp 4"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Now you can build everything with ",(0,r.kt)("inlineCode",{parentName:"p"},"gulp")," command"))),(0,r.kt)("p",null,"Native part of emulators is plain cmake project, you can open it\nin your favorite editor. Project have following targets:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"sokol"))," - js-dos v7 native version: dosbox + UI based on ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/floooh/sokol"},"sokol"),".\nThis version is exactly the same as the web version. ",(0,r.kt)("strong",{parentName:"li"},"You should use this target\nto contribute in js-dos v7.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"direct"))," - target is used to build the web-direct version of js-dos v7.\nYou can compile it only with ",(0,r.kt)("strong",{parentName:"li"},"emscripten"),"."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"strong"},"worker"))," - target is used to build the web-worker version of js-dos v7.\nYou can compile it only with ",(0,r.kt)("strong",{parentName:"li"},"emscripten"),"."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"dosbox")," - original version of dosbox (UI based on SDL). You can use\nit to compare behaviour between original dosbox and js-dos v7."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"libzip")," - shared codes that contain implementation of zip."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"jsdos")," - shared codes that contain implementation of dosbox.")),(0,r.kt)("h2",{id:"protocol"},"Protocol"),(0,r.kt)("p",null,"The idea of new js-dos v7 is that all targets (native and web) have exactly\nsame way to communicate between client (native UI, browser UI) and dosbox."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c",metastring:'title="https://raw.githubusercontent.com/js-dos/emulators/main/src/protocol/protocol.h"',title:'"https://raw.githubusercontent.com/js-dos/emulators/main/src/protocol/protocol.h"'},"{}\n")),(0,r.kt)("h2",{id:"server"},"Server"),(0,r.kt)("p",null,"For simplicity you can think that the server is a dosbox.\nIn the future servers can be implemented with different emulators. Now we support\nonly ",(0,r.kt)("strong",{parentName:"p"},"dosbox implementation")," (look at ",(0,r.kt)("inlineCode",{parentName:"p"},"jsdos.cmake"),")."),(0,r.kt)("h3",{id:"server_run"},"server_run()"),(0,r.kt)("p",null,"Client should run this function when it's ready to start dosbox. This\nfunction will start the emulator. Client should prepare file system for dosbox ",(0,r.kt)("strong",{parentName:"p"},"it\nexpect that ",(0,r.kt)("inlineCode",{parentName:"strong"},"cwd")," contains ",(0,r.kt)("inlineCode",{parentName:"strong"},".jsdos/dosbox.conf")," file"),". "),(0,r.kt)("p",null,"So you need to extract ",(0,r.kt)("a",{parentName:"p",href:"/v7/build/docs/#js-dos-bundle"},"js-dos bundle")," in some directory and start sokol binary\nin this directory, and it will act exactly in the same way as direct/worker dosbox."),(0,r.kt)("h3",{id:"server_add_keykeycode-pressed-timems"},"server_add_key(keycode, pressed, timeMs)"),(0,r.kt)("p",null,"This function adds keycode to the queue. They will be processed when dosbox poll keyboard\nevents."),(0,r.kt)("h3",{id:"server_exit"},"server_exit()"),(0,r.kt)("p",null,"Terminates execution of dosbox and free resources."),(0,r.kt)("h2",{id:"client"},"Client"),(0,r.kt)("p",null,"Direct, worker, and sokol implementations share the same code for server part. But they are completely different,\nbecause they implement UI and sound system for different platforms. In original dosbox this was made\nby SDL, it was hard-coupled with dosbox. js-dos clearly detaches the emulator from its ui. You can easily add new\nUI/sound system to dosbox. "),(0,r.kt)("p",null,"For example, let's look on sokol UI implementation. You can use it to debug and develop new features for js-dos.\nWorker is a primary web implementation for js-dos v7. sokol implementation tries to work in similar way: we start\ndosbox emulator in main thread and client in new thread."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void runRuntime() {\n  std::thread client(client_run);\n  server_run();\n  client.join();\n}\n")),(0,r.kt)("h3",{id:"client_frame_set_sizewidth-height"},"client_frame_set_size(width, height)"),(0,r.kt)("p",null,"When the server starts it will send the frame size of the dosbox window by invoking ",(0,r.kt)("inlineCode",{parentName:"p"},"client_frame_set_size"),". You should allocate rgba buffer to store frame content. This function will be called each time when dosbox window size is changed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"extern int frameWidth = 0;\nextern int frameHeight = 0;\nextern uint32_t *frameRgba = 0;\n\nvoid client_frame_set_size(int width, int height) {\n  std::lock_guard<std::mutex> g(mutex);\n\n  if (frameRgba) {\n    delete[] frameRgba;\n  }\n  frameWidth = width;\n  frameHeight = height;\n  frameRgba = new uint32_t[width * height];\n}\n")),(0,r.kt)("h3",{id:"client_frame_update_lineslines-count-rgba"},"client_frame_update_lines(lines, count, rgba)"),(0,r.kt)("p",null,"This method will be called each time if contents of dosbox window are changed. dosbox implementation\nwill send only changed lines. You need to update your frame buffer correctly."),(0,r.kt)("p",null,"Dirty region format (lines argument):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"line number [0, height)"),(0,r.kt)("li",{parentName:"ul"},"count of changed lines"),(0,r.kt)("li",{parentName:"ul"},"offset in passed buffer (rgba argument)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void client_frame_update_lines(uint32_t *lines, uint32_t count, void *rgba) {\n  std::lock_guard<std::mutex> g(mutex);\n\n  frameCount++;\n  if (!frameRgba) {\n    return;\n  }\n\n  for (uint32_t i = 0; i < count; ++i) {\n    uint32_t start = lines[i * 3];\n    uint32_t count = lines[i * 3 + 1];\n    uint32_t offset = lines[i * 3 + 2];\n    memcpy(&frameRgba[start * frameWidth], (char *)rgba + offset,\n           sizeof(uint32_t) * count * frameWidth);\n  }\n}\n")),(0,r.kt)("p",null,"Implementing ",(0,r.kt)("inlineCode",{parentName:"p"},"client_frame_set_size")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"client_frame_update_lines")," is enough to render\ndosbox window:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// ... \n   appDescription.frame_cb = []() { sokolFrame(); };\n// ...\n\nvoid sokolFrame() {\n  std::lock_guard<std::mutex> g(mutex);\n\n  // ...\n  \n  sg_image_content imageContent = {};\n  imageContent.subimage[0][0] = {};\n  imageContent.subimage[0][0].ptr = frameRgba;\n  imageContent.subimage[0][0].size =\n      (state->width) * (state->height) * (int)sizeof(uint32_t);\n\n  sg_update_image(state->bind.fs_images[0], &imageContent);\n\n  sg_begin_default_pass(&state->pass, state->width, state->height);\n  sg_apply_pipeline(state->pipeline);\n  sg_apply_bindings(&state->bind);\n  sg_draw(0, 4, 1);\n  sg_end_pass();\n  sg_commit();\n\n  renderedFrame = frameCount;\n}\n")),(0,r.kt)("h3",{id:"client_sound_initfreq"},"client_sound_init(freq);"),(0,r.kt)("p",null,"Called when the dosbox needs to initialize the sound system. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void client_sound_init(int freq) {\n  saudio_desc audioDescription = {};\n  audioDescription.sample_rate = static_cast<int>(freq);\n  audioDescription.num_channels = 1;\n\n  saudio_setup(&audioDescription);\n  assert(saudio_isvalid());\n}\n")),(0,r.kt)("h3",{id:"client_sound_pushsamples-num_samples"},"client_sound_push(samples, num_samples)"),(0,r.kt)("p",null,"This method is called each time when new sound samples should be pushed to audio device.\nWith sokol implementation is very simple:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void client_sound_push(const float *samples, int num_samples) {\n  saudio_push(samples, num_samples);\n}\n")),(0,r.kt)("h3",{id:"client_stdoutdata-amount"},"client_stdout(data, amount)"),(0,r.kt)("p",null,"This method will be called each time when dosbox prints something to its console."),(0,r.kt)("h3",{id:"communicate-to-server"},"Communicate to server"),(0,r.kt)("p",null,"Each time when key is pressed we should send event to dosbox:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// ...\n  appDescription.event_cb = [](const sapp_event *event) {\n    switch (event->type) {\n      case SAPP_EVENTTYPE_KEY_DOWN:\n      case SAPP_EVENTTYPE_KEY_UP:\n        keyEvent(event);\n        break;\n      default:;\n    }\n  };\n// ...\n\n\nvoid keyEvent(const sapp_event *event) {\n  server_add_key(\n      (KBD_KEYS)event->key_code,\n      event->type == SAPP_EVENTTYPE_KEY_DOWN,\n      GetMsPassedFromStart());\n}\n")),(0,r.kt)("p",null,"When user closes sokol window we need to stop server:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"  appDescription.cleanup_cb = []() { server_exit(); };\n")),(0,r.kt)("p",null,"That is. Check complete ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/js-dos/emulators/tree/main/src/dos/sokol"},"source")," of sokol implementation."),(0,r.kt)("h2",{id:"testing"},"Testing"),(0,r.kt)("p",null,"If the ",(0,r.kt)("inlineCode",{parentName:"p"},"gulp")," command is finished successfully then you can run emulators tests.\nTo do this, run a static web server to host the ",(0,r.kt)("inlineCode",{parentName:"p"},"dist")," directory. For example, with ",(0,r.kt)("inlineCode",{parentName:"p"},"http-server"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"hs dist\n")),(0,r.kt)("p",null,"and open test page in browser:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"firefox http://127.0.0.1:8080/test/test.html\n")),(0,r.kt)("p",null,"all tests should pass."),(0,r.kt)("h2",{id:"running-native-js-dos-v7"},"Running native js-dos v7"),(0,r.kt)("p",null,"As said above, you need to compile a ",(0,r.kt)("inlineCode",{parentName:"p"},"sokol")," target with your favorite C++ toolkit. It will generate ",(0,r.kt)("inlineCode",{parentName:"p"},"sokol"),"\nexecutable. Next, you need to download some ",(0,r.kt)("a",{parentName:"p",href:"/v7/build/docs/#js-dos-bundle"},"js-dos bundle")," for example\n",(0,r.kt)("a",{parentName:"p",href:"https://talks.dos.zone/t/digger-may-06-1999/1922"},"digger"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"js-dos bundle")," is a plain zip archive, you need to extract it in some folder. After that you\nshould run ",(0,r.kt)("inlineCode",{parentName:"p"},"sokol")," executable from that folder (cwd must be the root of the extracted bundle). "),(0,r.kt)("h2",{id:"using-docker"},"Using Docker"),(0,r.kt)("p",null,"You can use docker image to develop emulators core. The image has already configured\neverything to build emulators core and start emulators tests."),(0,r.kt)("h3",{id:"build-image"},"Build image"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"    docker build -t emulators . \n")),(0,r.kt)("h3",{id:"test-image"},"Test image"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"    docker run -p 8080:8080 -ti emulators\n")),(0,r.kt)("p",null,"Open ",(0,r.kt)("inlineCode",{parentName:"p"},"http://localhost:8080")," in browser, all tests should pass"),(0,r.kt)("h3",{id:"development"},"Development"),(0,r.kt)("p",null,"Run inside the project dir:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"    docker run -v `pwd`/src:/app/src -v `pwd`/test:/app/test -v `pwd`/dist:/app/dist -ti emulators bash\n    source /emsdk/emsdk_env.sh\n    gulp OR ./node_modules/.bin/tsc --watch\n")),(0,r.kt)("p",null,"Use your code editor to edit the content of src and test.\nIn the docker VM you can run ",(0,r.kt)("inlineCode",{parentName:"p"},"gulp")," to build everything into ",(0,r.kt)("inlineCode",{parentName:"p"},"dist")," OR use\n",(0,r.kt)("inlineCode",{parentName:"p"},"./node_modules/.bin/tsc --watch")," if you need only compile time checks."),(0,r.kt)("h2",{id:"contributing-on-github"},"Contributing on github"),(0,r.kt)("p",null,"To contribute your code please create PR on github, and check if all tests passed."))}p.isMDXComponent=!0}}]);